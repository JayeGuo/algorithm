# 一、简介

给定两个有序链表，要求合并后，还是有序的

# 二、

思路：不断比较两个列表的第一个元素，将较小的节点纳入新链表中

```
 public ListNode Merge(ListNode list1,ListNode list2) {
		if (list1 == null) return list2;
		if (list2 == null) return list1;
		ListNode dummyNode = new ListNode(-1);
		ListNode curNode = dummyNode;
		while (list1 !=null && list2 !=null) {
				ListNode temp;
				if (list1.val < list2.val) {
						temp = list1;
						list1 = list1.next;
				} else {
						temp = list2;
						list2 = list2.next;
				}
				curNode.next = temp;
				curNode = curNode.next;
		}
		while (list1 != null) {
				curNode.next = list1;
				curNode = curNode.next;
				list1 = list1.next;
		}
		while (list2 != null) {
				curNode.next = list2;
				curNode = curNode.next;
				list2 = list2.next;
		}
 		return dummyNode.next;
 }
```

# 三、问题

1、链表的最后，不用一个个处理了，直接连接起来。

```
while (list1 != null) {
				curNode.next = list1;
				curNode = curNode.next;
				list1 = list1.next;
		}

curNode.next = list1;
```

# 四、递归写法

```
 public ListNode Merge(ListNode list1,ListNode list2) {
 		if (list1 == null) return list2;
 		if (list2 == null) return list1;
 		
 		if (list1.val < list2.val) {
 			list1.next = Merge(list1.next, list2);
 			return list1;
 		}
 
		list2.next = Merge(list1, list2.next);
		return list2;
 }
```

递归要着重学些，然后练习，别瞎几把等了，就现在学！！

重点学！